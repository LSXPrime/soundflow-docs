---
id: 8
title: Recording Audio
description: Comprehensive tutorials for recording audio from devices and processing it in real-time with SoundFlow.
navOrder: 8
category: Tutorials and Examples
---
import {Tab, Tabs} from "@heroui/react";
import {Steps, Step} from '/src/components/Shared/Steps';

# Audio Recording with SoundFlow

Welcome to the SoundFlow audio recording tutorials! This guide will walk you through the essential steps to integrate audio recording capabilities into your .NET applications using the powerful SoundFlow C# audio library.

Whether you're looking to record from the default device, perform custom real-time audio processing, or monitor microphone input, these examples have you covered.

<Tabs color="secondary" variant="underlined" aria-label="Recording tutorials">
    <Tab key="basic-recording" title="Basic Recording">
        This tutorial demonstrates how to record audio from the default recording device and save it to a WAV
        file, with robust error handling.
        <Steps>
            <Step title="Create & Install" description="Setup project & package"
                  icon='ic:outline-create-new-folder'>
                ### 1. Create a new console application and install SoundFlow:
                ```bash
                dotnet new console -o BasicRecording
                cd BasicRecording
                dotnet add package SoundFlow
                ```
            </Step>
            <Step title="Write Code" description="Implement the basic recorder" icon='ph:code-bold'>
                ### 2. Replace the contents of `Program.cs` with the following code:
                ```csharp
                using SoundFlow.Abstracts.Devices;
                using SoundFlow.Backends.MiniAudio;
                using SoundFlow.Components;
                using SoundFlow.Enums;
                using SoundFlow.Structs;
                using System;
                using System.IO;
                using System.Linq;
                using System.Threading.Tasks;

                namespace BasicRecording;

                internal static class Program
                {
                    private static async Task Main(string[] args)
                    {
                        // Initialize the audio engine.
                        using var audioEngine = new MiniAudioEngine();

                        // Find the default capture (recording) device.
                        var defaultCaptureDevice = audioEngine.CaptureDevices.FirstOrDefault(d => d.IsDefault);
                        if (defaultCaptureDevice.Id == IntPtr.Zero)
                        {
                            Console.WriteLine("No default capture device found.");
                            return;
                        }

                        // Define the audio format for recording.
                        var audioFormat = new AudioFormat
                        {
                            Format = SampleFormat.F32,
                            SampleRate = 48000,
                            Channels = 1 // Mono recording
                        };
                        
                        // Initialize the capture device.
                        using var device = audioEngine.InitializeCaptureDevice(defaultCaptureDevice, audioFormat);
                        
                        // Set up the output file path.
                        var outputFilePath = Path.Combine(Directory.GetCurrentDirectory(), "output.wav");
                        
                        // Create a recorder, linking it to the capture device and the output file path.
                        // The recorder will manage the file stream internally.
                        using var recorder = new Recorder(device, outputFilePath, "wav");

                        Console.WriteLine("Recording... Press any key to stop.");
                        device.Start();
                        
                        // StartRecording now returns a Result object for error handling.
                        var startResult = recorder.StartRecording();
                        if (startResult.IsFailure)
                        {
                            Console.WriteLine($"Failed to start recording: {startResult.Error?.Message}");
                            device.Stop();
                            return;
                        }
                        
                        Console.ReadKey();
                        
                        // StopRecordingAsync also returns a Result.
                        var stopResult = await recorder.StopRecordingAsync();
                        device.Stop();
                        
                        if (stopResult.IsFailure)
                        {
                            Console.WriteLine($"Failed to stop recording cleanly: {stopResult.Error?.Message}");
                        }
                        else
                        {
                            Console.WriteLine($"Recording stopped. Saved to {outputFilePath}");
                        }
                    }
                }
                ```
            </Step>
            <Step title="Run Application" description="Build and run the app" icon='lucide:play'>
                ### 3. Build and run the application:
                ```bash
                dotnet run
                ```
            </Step>
        </Steps>

        **Explanation:**
        First, an `AudioEngine` is initialized. We find the `default capture device` from the engine's list of available recording devices. An `AudioFormat` is specified for the recording session (e.g., 48kHz, mono, 32-bit float).

        The default capture device is then initialized with this format, creating an `AudioCaptureDevice`. This `device` instance is now the source of our audio data.

        A `Recorder` is created, taking the `device` and an output file path. The recorder listens to the audio data processed by the device.

        To begin, `device.Start()` is called to activate the hardware. Then, `recorder.StartRecording()` is called. This method now returns a `Result` object. We check `startResult.IsFailure` to ensure the recording began successfully. If not, we log the error and exit. After the user presses a key, `recorder.StopRecordingAsync()` is called and its result is also checked to ensure the file was finalized correctly.
    </Tab>

    <Tab key="custom-processing" title="Real-Time Processing">
        This tutorial demonstrates using a callback to process recorded audio in real-time.
        <Steps>
            <Step title="Create & Install" description="Setup project & package"
                  icon='ic:outline-create-new-folder'>
                ### 1. Create a new console application and install SoundFlow:
                ```bash
                dotnet new console -o CustomProcessing
                cd CustomProcessing
                dotnet add package SoundFlow
                ```
            </Step>
            <Step title="Write Code" description="Implement real-time processing" icon='ph:code-bold'>
                ### 2. Replace the contents of `Program.cs` with the following code:
                ```csharp
                using SoundFlow.Abstracts;
                using SoundFlow.Abstracts.Devices;
                using SoundFlow.Backends.MiniAudio;
                using SoundFlow.Components;
                using SoundFlow.Enums;
                using SoundFlow.Structs;
                using System;
                using System.Linq;
                using System.Threading.Tasks;

                namespace CustomProcessing;

                internal static class Program
                {
                    private static async Task Main(string[] args)
                    {
                        using var audioEngine = new MiniAudioEngine();
                        
                        var defaultCaptureDevice = audioEngine.CaptureDevices.FirstOrDefault(d => d.IsDefault);
                        if (defaultCaptureDevice.Id == IntPtr.Zero)
                        {
                            Console.WriteLine("No default capture device found.");
                            return;
                        }

                        var audioFormat = new AudioFormat
                        {
                            Format = SampleFormat.F32,
                            SampleRate = 48000,
                            Channels = 1
                        };
                        
                        using var device = audioEngine.InitializeCaptureDevice(defaultCaptureDevice, audioFormat);
                        
                        // Create a recorder that uses a callback instead of a file stream.
                        using var recorder = new Recorder(device, ProcessAudio);

                        Console.WriteLine("Recording with custom processing... Press any key to stop.");
                        device.Start();
                        
                        var startResult = recorder.StartRecording();
                        if (startResult.IsFailure)
                        {
                            Console.WriteLine($"Failed to start recording: {startResult.Error?.Message}");
                            device.Stop();
                            return;
                        }
                        
                        Console.ReadKey();
                        
                        await recorder.StopRecordingAsync();
                        device.Stop();
                        Console.WriteLine("Recording stopped.");
                    }

                    // This method will be called for each chunk of recorded audio.
                    private static void ProcessAudio(Span<float> samples, Capability capability)
                    {
                        // Perform custom processing on the audio samples.
                        // For example, calculate the average level:
                        float sum = 0;
                        for (int i = 0; i < samples.Length; i++)
                        {
                            sum += Math.Abs(samples[i]);
                        }
                        float averageLevel = sum / samples.Length;

                        Console.WriteLine($"Average level: {averageLevel:F4}");
                    }
                }
                ```
            </Step>
            <Step title="Run Application" description="Build and run the app" icon='lucide:play'>
                ### 3. Build and run the application:
                ```bash
                dotnet run
                ```
            </Step>
        </Steps>

        **Explanation:**
        This example demonstrates how to process audio data in real-time as it's being recorded. After the standard setup of initializing the `AudioEngine` and the default `AudioCaptureDevice`, a `Recorder` is created.

        Instead of providing a file stream, this `Recorder` is given a callback method, `ProcessAudio`. The `Recorder` subscribes to the `device`'s `OnAudioProcessed` event. When the recorder is started via `recorder.StartRecording()`, we check the returned `Result` for any errors. If successful, the recorder will invoke our `ProcessAudio` method every time the device provides a new chunk of audio data.

        The `ProcessAudio` method receives a `Span<float>` containing the latest audio samples and the audio format, allowing for immediate analysis or processing, such as calculating the average level shown in this example. This approach is ideal for applications that need to react to live audio input without writing to a file, like voice activity detection, real-time visualizations, or triggering events based on sound.
    </Tab>
    
    <Tab key="authenticated-recording" title="Authenticated Recording">
        This tutorial demonstrates how to create a digitally signed recording, which guarantees the file's authenticity and integrity.
        <Steps>
            <Step title="Create & Install" description="Setup project & package"
                  icon='ic:outline-create-new-folder'>
                ### 1. Create a new console application and install SoundFlow:
                ```bash
                dotnet new console -o AuthenticatedRecording
                cd AuthenticatedRecording
                dotnet add package SoundFlow
                ```
            </Step>
            <Step title="Write Code" description="Implement a signing recorder" icon='ph:code-bold'>
                ### 2. Replace the contents of `Program.cs` with the following code:
                ```csharp
                using SoundFlow.Abstracts.Devices;
                using SoundFlow.Backends.MiniAudio;
                using SoundFlow.Components;
                using SoundFlow.Enums;
                using SoundFlow.Security;
                using SoundFlow.Security.Configuration;
                using SoundFlow.Structs;
                using System;
                using System.IO;
                using System.Linq;
                using System.Threading.Tasks;

                namespace AuthenticatedRecording;

                internal static class Program
                {
                    private static async Task Main(string[] args)
                    {
                        // 1. Generate a key pair for signing.
                        // In a real application, you would load your private key securely
                        // and distribute your public key.
                        var signatureConfig = SignatureConfiguration.Generate();
                        Console.WriteLine("Generated a temporary key pair for this session.");

                        // 2. Standard audio engine and device setup.
                        using var audioEngine = new MiniAudioEngine();
                        var defaultCaptureDevice = audioEngine.CaptureDevices.FirstOrDefault(d => d.IsDefault);
                        if (defaultCaptureDevice.Id == IntPtr.Zero)
                        {
                            Console.WriteLine("No capture device found.");
                            return;
                        }

                        var audioFormat = new AudioFormat { Format = SampleFormat.F32, SampleRate = 48000, Channels = 1 };
                        using var device = audioEngine.InitializeCaptureDevice(defaultCaptureDevice, audioFormat);
                        
                        var outputFilePath = Path.Combine(Directory.GetCurrentDirectory(), "authenticated_output.wav");

                        // 3. Create a Recorder and configure it for signing.
                        using var recorder = new Recorder(device, outputFilePath, "wav");
                        recorder.SigningConfiguration = signatureConfig; // <-- The key step!

                        // 4. Record audio.
                        Console.WriteLine("Recording... Press any key to stop.");
                        device.Start();
                        recorder.StartRecording();
                        
                        Console.ReadKey();

                        // 5. Stop recording. This will automatically generate the .sig file.
                        var stopResult = await recorder.StopRecordingAsync();
                        device.Stop();
                        if (stopResult.IsFailure)
                        {
                            Console.WriteLine($"Failed to stop recording: {stopResult.Error?.Message}");
                            return;
                        }

                        Console.WriteLine($"Recording stopped. Saved to {outputFilePath}");
                        var signatureFilePath = outputFilePath + ".sig";
                        if (!File.Exists(signatureFilePath))
                        {
                            Console.WriteLine("Signature file was not created!");
                            return;
                        }
                        Console.WriteLine($"Signature file created at {signatureFilePath}");

                        // 6. Verify the recording's integrity.
                        Console.WriteLine("\nVerifying the integrity of the recording...");
                        var signature = await File.ReadAllTextAsync(signatureFilePath);
                        var verificationResult = await FileAuthenticator.VerifyFileAsync(outputFilePath, signature, signatureConfig);

                        if (verificationResult.IsSuccess && verificationResult.Value)
                        {
                            Console.WriteLine("Verification successful: The file is authentic and has not been tampered with.");
                        }
                        else
                        {
                            Console.WriteLine($"Verification failed: {verificationResult.Error?.Message ?? "Signature mismatch."}");
                        }
                    }
                }
                ```
            </Step>
            <Step title="Run Application" description="Build and run the app" icon='lucide:play'>
                ### 3. Build and run the application:
                ```bash
                dotnet run
                ```
            </Step>
        </Steps>

        **Explanation:**
        This example showcases how to create a tamper-proof audio recording using digital signatures.

        First, we generate a `SignatureConfiguration` which contains a public/private key pair. In a real-world scenario, you would securely store your private key and distribute only the public key.

        Next, after setting up the `Recorder` as usual, we assign our configuration to the `recorder.SigningConfiguration` property. This instructs the recorder that upon completion, it should generate a digital signature for the audio file it just created.

        When `recorder.StopRecordingAsync()` is called, two things happen: the `.wav` file is finalized, and a new file, `authenticated_output.wav.sig`, is created in the same directory. This `.sig` file contains the cryptographic signature.

        Finally, we demonstrate how to verify the file. We use the `FileAuthenticator.VerifyFileAsync` method, providing the path to the audio file, the signature content, and the configuration containing the *public key*. If the verification is successful, it proves two things:
        1.  **Integrity:** The audio file has not been altered in any way since it was recorded.
        2.  **Authenticity:** The recording was created by the holder of the private key.
    </Tab>

    <Tab key="mic-playback" title="Live Monitor">
        This tutorial demonstrates capturing microphone audio and playing it back in real-time.
        <Steps>
            <Step title="Create & Install" description="Setup project & package"
                  icon='ic:outline-create-new-folder'>
                ### 1. Create a new console application and install SoundFlow:
                ```bash
                dotnet new console -o MicrophonePlayback
                cd MicrophonePlayback
                dotnet add package SoundFlow
                ```
            </Step>
            <Step title="Write Code" description="Implement microphone loopback" icon='ph:code-bold'>
                ### 2. Replace the contents of `Program.cs` with the following code:
                ```csharp
                using SoundFlow.Abstracts.Devices;
                using SoundFlow.Backends.MiniAudio;
                using SoundFlow.Components;
                using SoundFlow.Enums;
                using SoundFlow.Providers;
                using SoundFlow.Structs;
                using System;
                using System.Linq;

                namespace MicrophonePlayback;

                internal static class Program
                {
                    private static void Main(string[] args)
                    {
                        // Initialize the audio engine.
                        using var audioEngine = new MiniAudioEngine();

                        // Find the default playback and capture devices.
                        var defaultPlayback = audioEngine.PlaybackDevices.FirstOrDefault(d => d.IsDefault);
                        var defaultCapture = audioEngine.CaptureDevices.FirstOrDefault(d => d.IsDefault);
                        if (defaultPlayback.Id == IntPtr.Zero || defaultCapture.Id == IntPtr.Zero)
                        {
                            Console.WriteLine("Default playback and/or capture device not found.");
                            return;
                        }
                        
                        // Define a common audio format for both input and output.
                        var audioFormat = new AudioFormat
                        {
                            Format = SampleFormat.F32,
                            SampleRate = 48000,
                            Channels = 2 // Stereo for playback
                        };

                        // Use FullDuplexDevice for simplified simultaneous input and output.
                        using var fullDuplexDevice = audioEngine.InitializeFullDuplexDevice(defaultPlayback, defaultCapture, audioFormat);
                        
                        // Create a data provider that reads from the microphone.
                        // It subscribes to the capture device's audio events.
                        using var microphoneDataProvider = new MicrophoneDataProvider(fullDuplexDevice.CaptureDevice);
                        
                        // Create a SoundPlayer to play back the microphone data.
                        using var player = new SoundPlayer(audioEngine, audioFormat, microphoneDataProvider);

                        // Add the player to the playback device's master mixer.
                        fullDuplexDevice.PlaybackDevice.MasterMixer.AddComponent(player);

                        // Start capturing and playing.
                        fullDuplexDevice.Start();
                        microphoneDataProvider.StartCapture();
                        player.Play();

                        Console.WriteLine("Playing live microphone audio... Press any key to stop.");
                        Console.ReadKey();

                        // Stop everything.
                        fullDuplexDevice.Stop();
                    }
                }
                ```
            </Step>
            <Step title="Run Application" description="Build and run the app" icon='lucide:play'>
                ### 3. Build and run the application:
                ```bash
                dotnet run
                ```
            </Step>
        </Steps>

        **Explanation:**
        This example creates a real-time microphone monitoring system. The key component is the `FullDuplexDevice`, a high-level abstraction that simplifies managing simultaneous input and output.

        After initializing the `AudioEngine`, we find the default playback and capture devices and define a common `AudioFormat`. `audioEngine.InitializeFullDuplexDevice` is then called to create and manage a paired `AudioCaptureDevice` and `AudioPlaybackDevice`.

        A `MicrophoneDataProvider` is created and linked to the capture part of the full duplex device (`fullDuplexDevice.CaptureDevice`). This provider listens for incoming audio data.

        A `SoundPlayer` is instantiated with the `MicrophoneDataProvider` as its source. This player is then added to the `MasterMixer` of the playback part of the full duplex device (`fullDuplexDevice.PlaybackDevice.MasterMixer`).

        Starting the `fullDuplexDevice` activates both the capture and playback hardware streams. `microphoneDataProvider.StartCapture()` begins queuing the incoming audio, and `player.Play()` starts reading from that queue and sending the audio to the output, creating a live monitoring effect. All resources are managed with `using` statements for automatic cleanup.
    </Tab>
</Tabs>

We hope these tutorials have provided a solid foundation for recording audio with SoundFlow!
Next, explore using audio effects with SoundFlow in our [Modifiers Tutorial](./tutorials-modifiers).