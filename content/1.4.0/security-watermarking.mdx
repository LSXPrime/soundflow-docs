---
id: 23
title: Audio Watermarking
description: Learn how to embed invisible data into your audio for ownership tracking (Robust) and tamper detection (Fragile).
navOrder: 23
category: Security
---

import { Card, CardBody } from "@heroui/react";
import { Steps, Step } from '/src/components/Shared/Steps';

# Audio Watermarking

Watermarking allows you to embed hidden digital data directly into the audio signal itself. Unlike metadata tags (ID3, Vorbis Comments) which can be easily stripped or edited, watermarks persist as part of the waveform.

SoundFlow provides two distinct types of watermarking:

1.  **Ownership (Robust):** Uses *Direct Sequence Spread Spectrum (DSSS)*. The data is resilient to compression (MP3/AAC), noise, and re-encoding. Used for copyright tracking and leak identification.
2.  **Integrity (Fragile):** Uses *Block-Chained LSB Steganography*. The data is extremely sensitive. Any modification to the audio (even changing 1 bit) destroys the chain. Used for authenticating recordings and tamper detection.

## 1. Ownership Watermarking (Robust)

Ownership watermarking embeds a text payload (like a User ID or Transaction Code) into the audio. It is designed to be **inaudible** to the human ear but **detectable** by the software.

### Configuration

The `WatermarkConfiguration` controls the balance between robustness and transparency.

<Card>
    <CardBody>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
                <h4 className="font-bold text-sm">Key (Secret)</h4>
                <p className="text-xs text-default-500">A shared secret string. Only someone with this key can detect or extract the watermark.</p>
            </div>
            <div>
                <h4 className="font-bold text-sm">Strength (Alpha)</h4>
                <p className="text-xs text-default-500">0.01 (Invisible) to 0.15 (Audible). Higher is stronger against MP3 compression but adds more noise.</p>
            </div>
            <div>
                <h4 className="font-bold text-sm">Spread Factor</h4>
                <p className="text-xs text-default-500">Samples per bit. Higher = More Robust & Slower. Rec: 8192 - 16384.</p>
            </div>
        </div>
    </CardBody>
</Card>

### Workflow: Embed & Extract

<Steps>
    <Step title="Embed Watermark" icon="lucide:stamp">
        Use `AudioWatermarker.EmbedOwnershipWatermark` to process a file. This creates a new 32-bit Float WAV file with the watermark added.

        ```csharp
        using SoundFlow.Security;
        using SoundFlow.Security.Configuration;
        using SoundFlow.Providers;

        var config = new WatermarkConfiguration
        {
            Key = "MySecretStudioKey_2024",
            Strength = 0.08f,      // Balanced strength
            SpreadFactor = 16384   // High robustness
        };

        using var engine = new MiniAudioEngine();
        using var original = new AssetDataProvider(engine, "pre_release_track.wav");

        // Payload: Identifying the recipient of this copy
        string payload = "ReviewerID: 8821-X";

        Console.WriteLine("Embedding watermark...");
        
        // This writes to a file stream
        using var destStream = File.Create("track_watermarked.wav");
        AudioWatermarker.EmbedOwnershipWatermark(original, destStream, payload, config);
        
        Console.WriteLine("Done.");
        ```
    </Step>
    <Step title="Extract Watermark" icon="lucide:scan-search">
        Use `AudioWatermarker.ExtractOwnershipWatermarkAsync` to scan a file. This can be done on the same file, or a version that has been converted to MP3 and back.

        ```csharp
        // ... (Same config and engine setup) ...

        // Load the suspicious file (could be an MP3 converted back to WAV)
        using var suspicious = new AssetDataProvider(engine, "leaked_track.mp3");

        Console.WriteLine("Scanning for watermark...");

        var result = await AudioWatermarker.ExtractOwnershipWatermarkAsync(suspicious, config);

        if (result.IsSuccess)
        {
            Console.WriteLine($"Watermark Detected! Payload: {result.Value}");
            // Output: ReviewerID: 8821-X
        }
        else
        {
            Console.WriteLine("No watermark found, or signal too degraded.");
        }
        ```
    </Step>
</Steps>

### Auto-Tuning for Best Results

Choosing the right `Strength` and `SpreadFactor` can be tricky. It depends on the audio content (silence vs. loud rock). 

Use `WatermarkTuner` to automatically analyze your audio and find the strongest settings that still preserve audio quality.

```csharp
using SoundFlow.Security;

// 1. Load your source audio
using var source = new AssetDataProvider(engine, "track.wav");

// 2. Run the Auto-Tuner
// This simulates attacks (volume reduction, noise) to ensure robustness.
var optimalConfig = await WatermarkTuner.TuneConfigurationAsync(
    source, 
    payload: "UserID:12345", 
    secretKey: "MySecretKey",
    applySafetyMargin: true
);

Console.WriteLine($"Recommended Strength: {optimalConfig.Strength}");
Console.WriteLine($"Recommended Spread: {optimalConfig.SpreadFactor}");

// 3. Use the optimal config to embed
AudioWatermarker.EmbedOwnershipWatermarkToFile(source, "track_optimal.wav", "UserID:12345", optimalConfig);
```

## 2. Integrity Watermarking (Fragile)

Integrity watermarking is a real-time process. It builds a cryptographic chain of hashes where block `N` contains the hash of block `N-1`. If you silence a section, cut a part out, or overwrite it, the chain breaks at that exact point.

### Workflow: Real-Time Tamper Detection

This example sets up a "Secure Monitor" pipeline. It embeds the watermark during processing and immediately verifies it. In a real scenario, the verification would happen at the receiving end (e.g., an archival server).

<Steps>
    <Step title="Setup Pipeline" icon="carbon:flow">
        Create a processing chain with both the Embedder (Modifier) and the Verifier (Analyzer).

        ```csharp
        using SoundFlow.Security.Configuration;
        using SoundFlow.Security.Modifiers;
        using SoundFlow.Security.Analyzers;

        // Configuration determines the block size (resolution of detection).
        var config = new WatermarkConfiguration { IntegrityBlockSize = 4096 };
        var format = AudioFormat.DvdHq;

        // 1. The Source (e.g., Microphone or File)
        var player = new SoundPlayer(engine, format, provider);

        // 2. The Embedder (Injects the fragile hash)
        // Must be added as a Modifier to modify the stream in-place.
        var embedder = new IntegrityWatermarkEmbedModifier(config);
        player.Modifiers.Add(embedder);

        // 3. The Verifier (Checks the hash chain)
        // Added as an Analyzer (reads the stream).
        var verifier = new IntegrityWatermarkVerifyAnalyzer(format, config);
        player.Analyzers.Add(verifier);
        ```
    </Step>
    <Step title="Handle Violations" icon="lucide:shield-alert">
        Subscribe to the `IntegrityViolationDetected` event to react to tampering.

        ```csharp
        verifier.IntegrityViolationDetected += (blockIndex) =>
        {
            double timeSeconds = (double)(blockIndex * config.IntegrityBlockSize) / format.SampleRate;
            
            Log.Critical($"TAMPERING DETECTED at {timeSeconds:F2}s!");
            
            // Action: Stop playback, flag the file, or notify admin.
            player.Stop();
        };

        // Start the pipeline
        player.Play();
        ```
    </Step>
</Steps>

### When to use which?

| Feature          | **Ownership (Robust)**                    | **Integrity (Fragile)**                |
|:-----------------|:------------------------------------------|:---------------------------------------|
| **Primary Goal** | Identify the owner/recipient.             | Verify the content hasn't changed.     |
| **Resilience**   | Survives MP3, AAC, noise, volume changes. | Breaks on *any* bit change.            |
| **Audibility**   | Ideally inaudible (masked by audio).      | Strictly inaudible (LSB manipulation). |
| **Data Rate**    | Very Low (approx. 40 bits/sec).           | High (1 bit per sample).               |
| **Use Case**     | Copyright, Leak Tracking.                 | Evidence recording, Secure Archival.   |